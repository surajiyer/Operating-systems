/*
* Operating Systems  (2INC0)  Practical Assignment
* Condition Variables Application
*
* XIANG TENG (851499)
* Suraj Iyer (866094)
*
* Grading:
* Students who hand in clean code that fully satisfies the minimum requirements will get an 8. 
 * "Extra" steps can lead to higher marks because we want students to take the initiative. 
 * Extra steps can be, for example, in the form of measurements added to your code, a formal 
 * analysis of deadlock freeness etc.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <errno.h>
#include <pthread.h>
#include <unistd.h>     // for usleep()

#include "prodcons.h"

// create a bitmask of n bits
#define BITS_MASK(n)        ((1 << (n)) - 1)

/* buffer[]
* circular buffer that holds the items generated by the producer and
* which have to be retrieved by consumers
*/
static ITEM   		buffer[BUFFER_SIZE];
static unsigned int bufferSize = 0;

/* Initialize mutex and condition variable objects*/
static pthread_mutex_t	bufferMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t 	isEmpty = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t  producerSignalMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t 	producerSignal[NROF_CONSUMERS];

static void rsleep(int t);

/* producer thread */
static void * producer(void * arg)
{
	ITEM 				item;   	// a produced item
	unsigned int		seq = 1;	// sequence number of item
	unsigned int 		dest;		// destination consumer of item
	static unsigned int index = 0;	// input index of buffer[]
	srandom(time(NULL));			// seed the random generator with the current time
	
	while (seq <= NROF_ITEMS + NROF_CONSUMERS) 
	{
		rsleep(PRODUCER_SLEEP_FACTOR);
		
		// Produce new item
		if(seq <= NROF_ITEMS) {
			dest = random() % NROF_CONSUMERS;
			item = (seq << NROF_BITS_DEST) | dest;
			printf("%04x\n", item); // write info to stdout
		} else {
			dest = seq - NROF_ITEMS - 1;
			item = dest;
		}
		seq++;
		
		// Add new item to buffer[]
		pthread_mutex_lock(&bufferMutex);
		{
			// Wait until buffer is free
			while(bufferSize >= BUFFER_SIZE) {
				pthread_cond_wait (&isEmpty, &bufferMutex);
			}
			
			// Add item to buffer
			buffer[index] = item;
			index = (index + 1) % BUFFER_SIZE;
			bufferSize++;
			
			// Send a signal only if this is the first element in the buffer
			if(bufferSize == 1) {
				// Notify destination consumer
				pthread_mutex_lock(&producerSignalMutex);
				pthread_cond_signal (&producerSignal[dest]);
				pthread_mutex_unlock(&producerSignalMutex);
			}
		}
		pthread_mutex_unlock(&bufferMutex);
	}
	
	return NULL;
}

/* consumer thread */
static void * consumer(void * arg)
{
	ITEM    		item;   			// a consumed item
	int     		id = (int) arg;     // identifier of this consumer (value 0..NROF_CONSUMERS-1)
	static unsigned int	retr_index = 0;	// retrieval index of buffer[]
	unsigned int	seq;				// sequence number of item
	unsigned int 	dest;				// destination consumer of item
	
	while (1)
	{
		rsleep(NROF_CONSUMERS);
		
		// Retrieve item from buffer[]
		pthread_mutex_lock(&bufferMutex);
		{
			// Check oldest item from buffer
			item = buffer[retr_index];
			dest = item & BITS_MASK(NROF_BITS_DEST);
			if(dest != id) {
				pthread_mutex_lock(&producerSignalMutex);
				pthread_cond_signal (&producerSignal[dest]);
				pthread_mutex_unlock(&producerSignalMutex);
			}
			
			// Check if it can retrieve an item
			while(dest != id || bufferSize == 0) {
				pthread_cond_wait (&producerSignal[id], &bufferMutex);
				item = buffer[retr_index];
				dest = item & BITS_MASK(NROF_BITS_DEST);
				if(dest != id) {
					pthread_mutex_lock(&producerSignalMutex);
					pthread_cond_signal (&producerSignal[dest]);
					pthread_mutex_unlock(&producerSignalMutex);
				}
			}
			
			// Retrieve item from buffer
			item = buffer[retr_index];
			
			// Increment the retrieval index
			retr_index = (retr_index + 1) % BUFFER_SIZE;
			
			// Decrement the buffer items size and send a signal if necessary
			bufferSize--;
			
			// Get sequence number and destination from item
			seq = item >> NROF_BITS_DEST;
			dest = item & BITS_MASK(NROF_BITS_DEST);
			
			// Send a buffer size decremented signal to producer
			if(bufferSize < BUFFER_SIZE)
				pthread_cond_signal (&isEmpty);
			
			// If there is another element in the buffer, 
			if(bufferSize > 0) { // then send a signal to the corresponding consumer
				dest = buffer[retr_index] & BITS_MASK(NROF_BITS_DEST);
				if(dest != id) {
					pthread_mutex_lock(&producerSignalMutex);
					pthread_cond_signal (&producerSignal[dest]);
					pthread_mutex_unlock(&producerSignalMutex);
				}
			}
		}
		pthread_mutex_unlock(&bufferMutex);
		
		if(seq != 0) {
			// write info to stdout (with indentation)
			printf("%*s    C%d:%04x\n", 7 * id, "", id, item);
		} else {
			break;
		}
	}
	
	return NULL;
}

int main(void)
{ 
	// Create threads for producer and consumers
	pthread_t idP, idC[NROF_CONSUMERS];
	
	// startup the producer thread and the consumer threads
	int id;
	for (id = 0; id < NROF_CONSUMERS; id++) {
		pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
		producerSignal[id] = cond;
		pthread_create(&idC[id], NULL, consumer, (void*)id);
	}
	pthread_create(&idP, NULL, producer, NULL);
	
	// Join all threads
	pthread_join(idP, NULL);
	for (id = 0; id < NROF_CONSUMERS; id++)
	{
		pthread_join(idC[id], NULL);
		pthread_cond_destroy(&producerSignal[id]);
	}
	
	// Destroy remaining mutexes and condition variables
	pthread_mutex_destroy(&bufferMutex);
	pthread_mutex_destroy(&producerSignalMutex);
	pthread_cond_destroy(&isEmpty);
	
	return (0);
}

/*
* rsleep(int t)
*
* The calling thread will be suspended for a random amount of time between 0 and t microseconds
* At the first call, the random generator is seeded with the current time
*/
static void rsleep(int t)
{
	static bool first_call = true;

	if (first_call == true)
	{
		srandom(time(NULL));
		first_call = false;
	}
	usleep(random() % t);
}

