/* 
 * Operating Systems  (2INC0)  Practical Assignment
 * Interprocess Communication
 *
 * Code extracted from: http://www.linuxjournal.com/article/4879
 *
 * compilation: gcc -I /usr/X11/include -L /usr/X11/lib -o x x.c -lX11
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>

#include "settings.h"

#ifdef WITH_X11
    #include <X11/Xlib.h>
#endif

/* treat the iteration (0..MAX_ITER) as a RGB color
 * these defines give the depth of the colors in the iteration
 * make sure that there are enought bits (RED_BITS + GREEN_BITS + BLUE_BITS)
 * to hold the value of MAX_ITER 
 */
#define RED_BITS        3
#define GREEN_BITS      3
#define BLUE_BITS       3

/* converting a iteration-value (0..MAX_ITER) into a 24-bit color
 * (8-bits red + 8-bits green + 8-bits blue)
 */
 
// positions and masks of the colors in the iteration-value:
#define RED_POSITION    (0)
#define GREEN_POSITION  (BLUE_BITS)
#define BLUE_POSITION   (GREEN_BITS + BLUE_BITS)

#define RED_MASK        ((1 << RED_BITS) - 1)
#define GREEN_MASK      ((1 << GREEN_BITS) - 1)
#define BLUE_MASK       ((1 << BLUE_BITS) - 1)

// place in the 24-bit color
#define RED_SHIFT       16
#define GREEN_SHIFT     8
#define BLUE_SHIFT      0

// characteristics of a BMP header
#define BMP_OFFSET_DATA 0x436
#define BMP_OFFSET_X    0x12
#define BMP_OFFSET_Y    0x16

#ifdef WITH_BMP

    static FILE *           fptr_bmp;

    static void
    bmp_init (void)
    {
        FILE *          fEmpty;
        char            filename[80];
        unsigned int    i;
        int             c;
        char            s[0x4];

        // copy the header from 'empty.bmp' (which is generated by Paint)
        
        fEmpty = fopen ("empty.bmp", "rb");
        if (fEmpty == NULL)
        {
            perror ("fopen('empty.bmp') failed");
        }
        sprintf (filename, "mandelbrot_%d.bmp", getpid());
        fptr_bmp = fopen (filename, "wb");
        if (fptr_bmp == NULL)
        {
            perror ("fopen('mandelbrot.bmp') failed");
        }

        // copy the BMP-header from a real BMP-file
        for (i = 0; i < BMP_OFFSET_DATA; i++)
        {
            c = fgetc (fEmpty);
            fputc (c, fptr_bmp);
        }
        if (i == BMP_OFFSET_DATA)
        {
            fclose (fEmpty);
        }

        // set the file-size
        fseek (fptr_bmp, BMP_OFFSET_X, SEEK_SET);
        i = X_PIXEL;
        s[0] =  X_PIXEL   & 0xff;
        s[1] = (i >>  8) & 0xff;
        s[2] = (i >> 16) & 0xff;
        s[3] = (i >> 24) & 0xff;
        fwrite (s, 4, 1, fptr_bmp);
        
        i = Y_PIXEL;
        s[3] = (i >> 24) & 0xff;
        s[2] = (i >> 16) & 0xff;
        s[1] = (i >>  8) & 0xff;
        s[0] =  Y_PIXEL   & 0xff;
        fseek (fptr_bmp, BMP_OFFSET_Y, SEEK_SET);
        fwrite (s, 4, 1, fptr_bmp);

        // patch the X-Y size in the BMP-header
        fseek (fptr_bmp, (Y_PIXEL * X_PIXEL) + BMP_OFFSET_X, SEEK_SET);
        i = 0xaa;
        fputc (i, fptr_bmp);
    }

    static void 
    bmp_draw_pixel (int x, int y, int i)
    {
        int pos;
        
        pos = BMP_OFFSET_DATA + x + (y * X_PIXEL);
        fseek (fptr_bmp, pos, SEEK_SET);
        fputc (i, fptr_bmp);
    }

    static void 
    bmp_end (void)
    {
        fclose (fptr_bmp);
    }

#endif
    
#ifdef WITH_X11

    static Display *        dsp;
    static Window           win;
    static GC               gc;

    static void 
    X11_init (void)
    {
        long    eventMask;
        XEvent  evt;
        
        dsp = XOpenDisplay (NULL);
        if (dsp == NULL)
        { 
            fprintf (stderr, "ERROR in XOpenDisplay()\n");
            exit (1);
        }
        win = XCreateSimpleWindow (dsp, DefaultRootWindow (dsp), 0, 0,
                                   X_PIXEL, Y_PIXEL, 0, 0, 0xeeeeee);
        XMapWindow (dsp, win);

        eventMask = StructureNotifyMask;
        XSelectInput (dsp, win, eventMask);

        do
        {
            XNextEvent (dsp, &evt);   // calls XFlush
        } while (evt.type != MapNotify);

        gc = XCreateGC (dsp, win, 0, NULL);
    }

    static void 
    X11_end (void)
    {
        char *  str = "press a mouse button to quit";
        long    eventMask;
        XEvent  evt;

        XSetForeground (dsp, gc, 0xffffff);
        XDrawString (dsp, win, gc, 20, Y_PIXEL - 20, str, strlen (str));

        eventMask = ButtonPressMask|ButtonReleaseMask;
        XSelectInput (dsp, win, eventMask); // override prev
    
        do
        {
            XNextEvent (dsp, &evt);   // calls XFlush()
        } while (evt.type != ButtonRelease);

        XDestroyWindow (dsp, win);
        XCloseDisplay (dsp);
    }

    static void 
    X11_draw_pixel (int x, int y, int i)
    {
        long int color; // 24-bit color
        long int red, green, blue;
        
        // the bits must be put in the MSB of red in the 24-bit color
        red   = i;
        red >>= RED_POSITION;
        red  &= RED_MASK;
        red <<= 8;
        red >>= RED_BITS;
        red <<= RED_SHIFT;
        
        green   = i;
        green >>= GREEN_POSITION;
        green  &= GREEN_MASK;
        green <<= 8;
        green >>= GREEN_BITS;
        green <<= GREEN_SHIFT;
        
        blue   = i;
        blue >>= BLUE_POSITION;
        blue  &= BLUE_MASK;
        blue <<= 8;
        blue >>= BLUE_BITS;
        blue <<= BLUE_SHIFT;
        
        color = red + green + blue;
        
        XSetForeground (dsp, gc, color);
        // pixel (0,0) is the left-upper corner, therefor we've to correct the y value
        XDrawPoint (dsp, win, gc, x, (Y_PIXEL - 1) - y);  
    }
    
#endif
    
void 
output_init (void)
{
#ifdef WITH_BMP
    bmp_init();
#endif
#ifdef WITH_X11
    X11_init();
#endif
}

void 
output_draw_pixel (int x, int y, int color)
{
#ifdef WITH_BMP
    bmp_draw_pixel (x, y, color);
#endif
#ifdef WITH_X11
    X11_draw_pixel (x, y, color);
#endif
}

void 
output_end (void)
{
#ifdef WITH_BMP
    bmp_end();
#endif
#ifdef WITH_X11
    X11_end();
#endif
}



